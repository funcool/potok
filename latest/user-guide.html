<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>User Guide</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">funcool/potok</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="user-guide.html"><div class="inner"><span>User Guide</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="potok.core.html"><div class="inner"><span>potok.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#user-guide" name="user-guide"></a>User Guide</h1>
<h2><a href="#introduction" name="introduction"></a>Introduction</h2>
<p>Potok is a tiny (100LOC) reactive streams based state management toolkit for ClojureScript.</p>
<p>Potok lies on top of two concepts: <em>events</em> and <em>reactive store</em>.</p>
<h2><a href="#install" name="install"></a>Install</h2>
<p>Just add this to your dependencies:</p>
<pre><code class="clojure">funcool/potok {:mvn/version "4.0.0"}
</code></pre>
<h2><a href="#getting-started" name="getting-started"></a>Getting Started</h2>
<h3><a href="#events" name="events"></a>Events</h3>
<p>The events are entities that your application will emit in order to send data or action to the store. They will be emitted using <code>potok.core/emit!</code> function. There are three types of events:</p>
<ul>
  <li><em>update</em>: that represents a synchronous state transformation.</li>
  <li><em>watch</em>: that represents an asynchronous operation.</li>
  <li><em>effect</em>: that represents a side effectful operation.</li>
</ul>
<p>Let’s see a detailed explanation of each event type:</p>
<h4><a href="#update-event" name="update-event"></a>Update Event</h4>
<p>The <em>update</em> event represents the simple synchronous state transformation. It just consists of a type defined using <em>defrecord</em>, builtin <code>reify</code> or the potok provided <code>reify</code> helper that already implements some additional protocols.</p>
<p>The <code>update</code> function receives the current state as argument and should return the transformed state. Let’s see an example:</p>
<pre><code class="clojure">(require '[potok.core :as ptk])

(defn increment
  []
  (ptk/reify ::increment
    ptk/UpdateEvent
    (update [_ state]
      (update state :counter (fnil inc 0)))))

;; or

(defrecord Increment []
  ptk/UpdateEvent
  (update [_ state]
    (update state :counter (fnil inc 0))))

</code></pre>
<p>The <code>::increment</code> keyword is a type tag that can be used later to filter events using the <code>ptk/type?</code> higher-order predicate <code>ptk/type</code> to obtain the type of the instance.</p>
<p>You may be thinking, the signature of the <code>update</code> function is very similar to a reduce function. And in fact, it does just that the state reduction, and it can be defined using a plain ClojureScript function:</p>
<pre><code class="clojure">(defn increment
  [state]
  (update state :counter (fnil inc 0))
</code></pre>
<h4><a href="#watch-event" name="watch-event"></a>Watch Event</h4>
<p>Apart from the simple state transformations, applications usually need to perform asynchronous operations such as call remote API, access local database, etc. This is where the <em>watch</em> events play their role. They are designed to handle asynchronous operations.</p>
<p>Let’s see how it looks:</p>
<pre><code class="clojure">(require '[beicon.core :as rx])

(defn delayed-increment-by
  [n]
  (ptk/reify ::delayed-increment-by
    ptk/WatchEvent
    (watch [_ state stream]
      (-&gt;&gt; (rx/of (increment-by n)) ; create a instance of `Increment` event
           (rx/delay 100))))          ; delay the stream for 100ms
</code></pre>
<p>The responsibility of the <code>watch</code> function is to perform an asynchronous operation and return a stream of one or more events. In the example, you can observe, that it just returns a stream of one <code>::increment</code> event instance delayed 100 milliseconds (thus emulating some latency).</p>
<p>That stream will be re-injected into the main stream and those events will be processed in the same way as if you emitted them with <code>potok.core/emit!</code> function.</p>
<p>The additional <code>stream</code> parameter to the <code>watch</code> function represents the main stream where all events will arrive, so you can build logic needed for a synchronization with other events or just a handling of some kind of a cancellation.</p>
<h4><a href="#effect-event" name="effect-event"></a>Effect Event</h4>
<p>The <em>effect</em> event represents a side effectfull action. In the same way as the <em>watch</em> event, it receives the current state and the main stream as arguments.</p>
<p>Let’s see how it look:</p>
<pre><code class="clojure">(defn notify
  [title message]
  (ptk/reify ::notify
    ptk/EffectEvent
    (effect [_ state stream]
      (let [params #js {:body message}]
        (js/Notification. title params)))))
</code></pre>
<p>The return value of the <code>effect</code> function is completely ignored.</p>
<h3><a href="#store" name="store"></a>Store</h3>
<p>In the previous section we have seen events, the <em>store</em> is the object that processes them. It has the following responsibilities:</p>
<ul>
  <li>Hold the application state.</li>
  <li>Process incoming events.</li>
  <li>Emit the changes using reactive streams.</li>
</ul>
<p>To create store you just need to execute the <code>potok.core/store</code> function:</p>
<pre><code class="clojure">(def store (ptk/store))
</code></pre>
<p>If no arguments is passed to <code>store</code> function, the initial state is initialized as <code>nil</code>. This is how you can provide an initial state:</p>
<pre><code class="clojure">(def store (ptk/store {:state {:counter 0}}))
</code></pre>
<p>The <code>store</code> object from the user perspective is an atom that implements RX Subject interface. The atom interface allows synchronous acces to the latest state and the Subject interface allow emits events into.</p>
<p>You can emit events into the store using the <code>ptk/emit!</code> or <code>beicon.core/push!</code> functions:</p>
<pre><code class="clojure">(ptk/emit! store (increment-by 1))
</code></pre>
<p>Now if you deref(erence) the state, you will see it transformed:</p>
<pre><code class="clojure">@store
;; =&gt; {:counter 1}
</code></pre>
<h3><a href="#error-handling" name="error-handling"></a>Error Handling</h3>
<p>In many circumstances we found, that exception is raised inside the event. For this case <em>potok</em> comes with the built-in mechanism for handling errors.</p>
<p>Let’s see some code:</p>
<p>[source, clojure]</p>
<pre><code>(defn- on-error
  [error]
  (js/console.error error))

(def store (ptk/store {:on-error on-error}))
</code></pre>
<p>Now, if an exception is raised inside an event it will report it to this function. The return value of on-error callback is ignored with exception of <code>watch</code> event, where the error handler can return an observable.</p>
<h2><a href="#developers-guide" name="developers-guide"></a>Developers Guide</h2>
<h3><a href="#philosophy" name="philosophy"></a>Philosophy</h3>
<p>Five most important rules:</p>
<ul>
  <li>Beautiful is better than ugly.</li>
  <li>Explicit is better than implicit.</li>
  <li>Simple is better than complex.</li>
  <li>Complex is better than complicated.</li>
  <li>Readability counts.</li>
</ul>
<p>All contributions to <em>potok</em> should keep these important rules in mind.</p>
<h3><a href="#contributing" name="contributing"></a>Contributing</h3>
<p>Unlike Clojure and other Clojure contributed libraries <em>potok</em> does not have many restrictions on contributions. Just open an issue or pull request.</p>
<h3><a href="#source-code" name="source-code"></a>Source Code</h3>
<p><em>potok</em> is open source and can be found on link:<a href="https://github.com/funcool/potok[github]">https://github.com/funcool/potok[github]</a>.</p>
<p>You can clone the public repository with this command:</p>
<p>[source,text]</p>
<pre><code>git clone https://github.com/funcool/potok
</code></pre>
<h2><a href="#faq" name="faq"></a>FAQ</h2>
<h3><a href="#what-is-the-motivation-behind-potok-" name="what-is-the-motivation-behind-potok-"></a>What is the motivation behind <em>potok</em>?</h3>
<p>My main motivation is just to simplify a number of concepts that user needs to learn in order to use one-way-flow state management. Reactive streams fit very well this purpose, so I decided not to reinvent the wheel and just use them (in contrast to re-frame or redux as an example).</p>
<p><em>Potok</em> has very small amount of the code and can be understood and maintained by almost anyone which makes the decision to include it in the production, without the fear of this library becomes unmaintained, easier.</p>
<p>It is just 100 lines of the pretty well-commented code.</p>
<h3><a href="#can-i-implement-more-than-one-event-protocol-at-the-same-time-" name="can-i-implement-more-than-one-event-protocol-at-the-same-time-"></a>Can I implement more than one event protocol at the same time?</h3>
<p>Yes, in fact, it is a very useful approach to performing optimistic updates, because the <em>update</em> event is always the first processed and the <em>watch</em> and <em>effect</em> events will receive the state already transformed by the <code>update</code> function.</p>
<h3><a href="#how-can-i-use-potok-with-react-js-based-web-applications-" name="how-can-i-use-potok-with-react-js-based-web-applications-"></a>How can I use <em>potok</em> with React.js based web applications?</h3>
<p>Very easy, once you have materialized the state into an atom, you can consume this atom from any react based toolkit (*rumext*, <em>reagent</em>, etc) in the same way, as you will consume a plain atom with the state.</p>
<p>The unique difference is that if you want to perform a state transformation, you need to define and emit an event for it, instead of direct state atom’s transformation.</p>
<h3><a href="#are-there-some-real-applications-using-this-pattern-" name="are-there-some-real-applications-using-this-pattern-"></a>Are there some real applications using this pattern?</h3>
<p>Yes, many of them are private, but there is one public: link:<a href="https://github.com/penpot/penpot[penpot]">https://github.com/penpot/penpot[penpot]</a>. It is the pretty big project and it demonstrates that this approach scales very well.</p>
<p>Also, there are some open source projects not connected to the funcool organization:</p>
<ul>
  <li>link:<a href="https://github.com/pepe/potok-rumu[potok-rumu">https://github.com/pepe/potok-rumu[potok-rumu</a>] - just example project  with the simple structure, for showing the potok capabilities. It also uses rum  for rendering.</li>
  <li>link:<a href="https://github.com/pepe/showrum[showrum">https://github.com/pepe/showrum[showrum</a>] - presentation software, which  uses potok for state management</li>
  <li>link:<a href="https://github.com/LastStar/proud[proud">https://github.com/LastStar/proud[proud</a>] - highly opinionated boot  template for generating new projects with potok and rum setup</li>
</ul>
<h2><a href="#license" name="license"></a>License</h2>
<p><em>potok</em> is licensed under BSD (2-Clause) license:</p>
<pre><code>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.

Copyright (c) Andrey Antukh &lt;niwi@niwi.nz&gt;
</code></pre></div></div></div></body></html>